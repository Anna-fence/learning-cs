# C++ Primer 5e

## chap1 开始

### 1.1 编写一个简单的C++程序

* `main`函数的返回类型必须是`int`，一般来说，返回0表示程序运行成功，非0的返回值的含义由系统定义，用来指出错误类型。

​		**一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。**

* IDE：将编译器与其他程序创建和分析工具包装在一起，集成开发环境

### 1.2 初识输入输出

* 流：随着时间的推移，字符是顺序生成或消耗的

* `istream`类型的对象：`cin`

  `ostream`类型的对象：`cout`、`cerr`（输出警告和错误消息，标准错误）、`clog`（输出程序运行时的一般性信息）

* `<<`运算符接受两个运算对象，左侧运算对象必须是一个`ostream`对象，右侧的运算对象就是要打印的值。此运算符将给定的值写到给定的`ostream`对象中。输出运算符的计算结果就是其左侧运算对象。

  下面两段代码就是等价的：

  第一段：

  `(std::cout << 'Enter two numbers:') << std::endl;`

  第二段：

  `std::cout << 'Enter two numbers:';`

  `std::out << std::endl;`

  注意：

  这里的`std::`表示后面的变量从属于`std`这个变量空间。`::`这个符号表示作用域。不同的变量空间中的变量互不影响，可以自己定义变量空间；如果在源文件开头写了`using namespace std;`就不需要再强调变量`cin`属于`std`了。

  同时，`endl`是一个被称为操纵符的特殊值。写入`endl`的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。如果想通过`print`来观察程序运行过程的话，应该保证缓冲区一直被刷新。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。** 

### 1.3 注释简介

* 注释不能嵌套

### 1.4 控制流

* `while`语句

* `for`语句

## chap2 变量和基本类型

### 2.1 基本内置类型

#### 2.1.1 算数类型

字节（byte）：可寻址的最小内存块

字（word）：存储的基本单元

大多数机器的字节由8比特构成；字有4字节或者8字节

`float`（1个字，32比特来表示）和`double`分别有7和16个有效位

* 带符号类型和无符号类型

  字符型被分为了三种：`char`、`signed char`、`unsigned char`。`char` 会表现为带符号/无符号中的任意一种

* 在算术表达式中不要使用`char`或者`bool`。因为类型`char`在一些机器上有符号
* 执行浮点数运算选用`double`。

####  2.1.2 类型转换

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值**总数**取模后的余数。
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。**此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据**
* 如果循环的条件中，用来计数的变量设置成了无符号数，要注意检查，小心死循环：

​		![image-20220831201009234](C:\Users\韦澜\AppData\Roaming\Typora\typora-user-images\image-20220831201009234.png)

* **注意：**切勿混用带符号类型和无符号类型

#### 2.1.3 字面值常量

啥是字面值常量？一看就知道是什么类型的常量。

* 0开头的整数表示八进制数，以0x或0X开头的代表十六进制数

* 字符和字符串字面值：
  * 字符串字面值：每个字符串结尾处添加一个空字符`'\0'`，因此实际长度要比内容+1
  * 区别`'a'`和`"A"`，前者长度是1，后者长度是2（因为是字符串）
  * 如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分割，则它们实际上是一个整体

* 转义序列

* 指针字面值：`nullptr`

注意：

`3.14`：`double`

`3.14f`：`float`

*也就是说小数的数据类型默认是`double`*

### 2.2 变量

#### 2.2.1 变量定义

> 本书认为对象是具有某种数据类型的内存空间。在使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或是否只读。

**初始化和赋值的区别：**

初始化：创建变量时赋予其一个初始值；

赋值：把对象的当前值擦除，而以一个新值来替代

*列表初始化*将在第三章继续介绍。

**定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。**（如果试图拷贝或以其他形式访问未定义的值，将引发错误）**类的对象如果没有显式地初始化，则其值由类确定。**（有些类规定必须要显式地初始化，否则会出错）

*练习*

`std::cin >> int input_value;`  // 非法，先定义一个整型变量，然后用外部输入进行赋值

`int i = {3.14};`   // 非法，浮点数无法为整型变量做初始化 

`double salary = wage = 9999.99;` // 非法，试了一下，编译的时候会报错，编译器认为`wage`是未被定义的变量

`int i = 3.14;`  // 强制类型转换，输出`i`的值为3

**初始化每一个内置类型的变量**

#### 2.2.2 变量声明和定义的关系

* 声明：名字为程序所知，规定了变量的类型和名字
  * 在变量前添加关键词`extern`，并且不要显式初始化变量（显式初始化会使得变量被定义，就不再是声明了）
* 定义：创建与名字关联的实体，申请存储空间，也可能为变量赋一个初始值
  * 变量**能且只能被定义一次**，但是可以被多次声明

**注意**：类似`int j;`的写法是既声明又定义

C++是一种静态类型(statically typed)语言，也就是说在编译阶段进行类型检查(type checking)

#### 2.2.3 标识符

* Yes:
  * 字母/下划线+数字
  * 对大小写敏感

* No:
  * 不能连续出现两个下划线
  * 不能以下划线紧连大写字母开头
  * 定义在函数体外的标识符不能以下划线开头

#### 2.2.4 名字的作用域

有效区域：始于**名字的声明语句**；结束于**所在作用域末端**

全局作用域；块作用域

```c++
#include <iostream>
using namespace std;
int main()
{
    int i = 100, sum = 0;
    for (int i = 0; i != 10; ++i)
        sum += i;
    cout << i << " " << sum << endl;
    return 0;
}
```

运行结果：

```
100 45
```

**注意：**`for`循环中`i`的作用域在line 7就结束了。所以最后输出的`i`的值是第五行定义的。

### 2.3 复合类型

#### 2.3.1 引用（&）

* 一般说的引用都是指左值引用
* 引用本身不是一个对象（所以只能绑定一个变量），不能定义引用的引用
* 实际上就是一个别名。如果别名和它要bind的对象类型不符，会发生强制类型转换

#### 2.3.2 指针（*）

* 指针与引用的不同点：
  * 指针本身就是一个对象，允许对指针复制和拷贝，在职者的呢生命周期内可以先后指向几个不同的对象
  * 指针无须在定义时赋初值（*也就是说指针也是一种内置类型。和其它内置类型一样，如果没有初始化的话就会有一个随机的初始值*）

* 取地址符 &
* 解引用符*
* **指针的类型要和它所指向的对象严格匹配**

**在声明语句中，&和*组成复合类型；在表达式中，它们的角色又转变成运算符。**



* 空指针

  建议初始化所有指针，如果实在不清楚指针应该指向何处，就把它初始化为`nullptr`或者`0`。（*虽然C++11里还有NULL可以用，但是尽量不要用*）



* 赋值和指针



* 其他指针操作

  两个类型相同的合法指针，可以用`==`/`!=`来比较：

  两个指针相等：

  * 两个指针存放的地址值相同

    他们都为空

    都指向同一个对象

    都指向了同一个对象的下一个地址

  * 一个指针指向某对象/另一个指针指向另外对象的下一地址



* `void*`指针

  不能直接操作`void*`指针所指的对象，因为不知道这个对象到底是什么类型（*以`void*`*的视角来看，内存空间仅仅是内存空间，没办法访问内存空间中所存的对象）

#### 2.3.3 理解复合类型的声明

* 定义多个变量

  ```c++
  int* p1, p2; //*是修饰变量的，是类型修饰符，所以p1是指针而p2是整型变量。
  ```

* 指向指针的指针

  用\*的个数区分指针的级别。（所以指向指针的指针应该有两个修饰符\*）

* 指向指针的引用

  ```c++
  int i = 42;
  int *p;
  int *&r = p; //表示r是对指针的引用
  
  r = &i;
  *r = 0;
  ```

  **离变量名最近的符号对变量的类型有最直接的影响；声明符的其余部分用以确定该变量的类型是什么。所以阅读一个比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。**

Ex:

```C++
int i, *p = 0; //这种声明方式只能说明p是一个空指针，
```



### 2.4 `const`限定符

* `const`一旦创建就不能再改变值，所以**必须初始化**。

* 默认状态下，`const`对象仅在文件内有效

  当多个文件中出现了同名的`const`变量时，等同于在不同文件中分别定义了独立的变量

  * 如果希望在多个文件中都能声明并且使用某个`const`变量（共享），可以在声明和定义的时候都在前面添加关键字`extern`

#### 2.4.1 `const`的引用

对常量的引用不能被用作修改它所绑定的对象。

```c++
const int ci = 1024;
const int &ri = ci; //注意对常量的引用得是常量引用（加const）

int &r2 = ci; //这样就是错的，因为r2不是常量引用
```

**常量引用是“对常量的引用”的简称**，因为引用不是对象，没办法让引用本身不变。（不过引用不能再指向别的变量了，所以也算是常量吧）

**引用的类型必须与其所引用的对象类型一致，但是有两个例外：**

1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果可以转成引用的类型即可。尤其是允许把一个**常量引用**绑定非常量的对象、字面值。

```c++
int i = 42;
const int &r1 = i;
const int &r2 = r1;
int &i3 = r1;  //非法
```

2. 

对`const`的引用可能引用一个并非`const`的对象

```C++
#include <iostream>
using namespace  std;

int main() {
    int i = 42;
    const int &r1 = i;  //一个常量引用
    int &r2 = i;
    r2 = 32;
    cout << "i is " << r1 << endl; //32
    cout << "const i is "<< r2 << endl;  //32

    return 0;
}
```

*也就是说可以是某个引用可以设置为常量引用，通过其它途径来改变这个被引用的变量的值*

#### 2.4.2 指针和`const`

**指针的类型必须与其所指向的对象类型一致，但是有两个例外：**

1. 允许令一个指向常量的指针指向一个非常量的对象



* `const`指针：

  ```c++
  int errNumb = 0;
  int *const curErr = &errNumb; //指向int的常量指针
  const double pi = 3.14159;
  const double *const pip = &pi; //指向常量的常量指针
  ```

  常量指针意思是指针本身不变，也就是说指针存储的地址值不会变了，而不是说指针指向的对象值不可改。

对于`const`来说，不管是常量指针还是普通的常量类型，都需要做初始化；

```c++
//下面的哪些初始化是合法的？请说明原因。
int i = -1, &r = 0; //不合法，引用必须初始化
int *const p2 = &i2; //合法，指向int的常量指针
const int i = -1, &r = 0; //合法，允许静态引用直接拿到一个字面值作为引用
const int *const p3 = &i2; //合法，p3是指向const int的常量指针
const int *p1 = &i2; //合法，p1是指向一个类型为const int的指针
const int &const r2; //没见过
const int i2 = i, &r = i; //合法
```

```c++
int i, *const cp; //不合法，cp是一个指向int的常量指针，必须初始化
int *p1, *const p2; //不合法
const int ic, &r = ic; //不合法，ic是一个常量int，必须先初始化
const int *const p3; //不合法，const指针必须初始化
const int *p; //合法，p是一个指向const int的指针
```

```c++
//假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。
i = ic; //合法，常量int可以赋值给int
p1 = p3; //不合法
p1 = &ic; //不合法，类型不符
p3 = &ic; //不合法，p3指向一个const int，同时又是常量指针
p2 = p1; //不合法，p1是普通的整形指针，存储的地址可以赋给一个常量指针
ic = *p3; //不合法，对p3取地址，得到一个const int，但是const int不能改变值
```

#### 2.4.3 顶层`const`

* 顶层`const`：
  * 表示指针本身是一个`const`
  * 可以表示任意的对象是常量

* 底层`const`：
  * 表示指针指向的对象是一个`const`
  * 与指针和引用等复合类型的基本类型部分有关

用于声明引用的`const`都是底层`const`

`int*`可以转换成`const int*`（*也就是普通类型的变量可以赋值给`const`*）

```c++
//对于下面的这些语句，请说明对象被声明称了顶层const还是底层const
const int v2 = 0; //顶层
int v1 = v2; //不是const
int *p1 = &v1, &ri = v1; //不是const
const int *p2 = &v2, *const p3 = &i, &r2 = v2;
//p2底层，p3顶层，r2是引用，所以是底层
```

```c++
//假设已有上一个练习中所作的那些声明，则下面的哪些语句是合法的？
//请说明顶层const和底层const在每个例子中有何体现？
r1 = v2; //拷贝时，v2作为一个顶层const，不受影响
p1 = p2; p2 = p1; //不合法，不都是底层；合法，int*可以转成const int*
p1 = p3; p2 = p3; //不合法，底层不都是const；合法，顶层const
```

#### 2.4.4 `constexpr`和常量表达式

* 常量表达式：

  值**不会改变**并且在**编译过程**就能得到计算结果的表达式。

一个对象/表达式是不是常量表达式由它的数据类型和初始值共同决定，注意以下两个例子：

```c++
int staff_size = 27; 
//虽然27是字面值，是一种常量表达式，但是staff_size的数据类型仅仅是int而非const int，所以并不是常量表达式
const int sz = get_size();
//虽然sz是const，但是它的值要到运行时才能得到，所以也不是常量表达式
```

* `constexpr`变量

  允许将变量声明为`constexpr`类型，以便由编译器来验证变量的值是否是一个常量表达式。

  **声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化**

* 字面值类型

  常量表达式的值需要在编译时就得到计算，因此对声明`constexpr`时用到的类型必须有所限制——字面值类型

* 指针和`constexpr`

  如果在`constexpr`声明中定义了一个指针，那么这个限定符只对指针有效，与指针所指对象无关

  

### 2.5 处理类型

#### 2.5.1 类型别名

`typedef`:

```c++
typedef double wages; //wages就是double
typedef wages base, *p; //wage和base一样（传递），*p=double *
```

别名声明：

```c++
using SI = Sale_item; //SI是Sale_item的别名
```

指针、常量和类型别名：

`const`是对**给定类型的修饰**：

```c++
typedef char *pstring; 
//这句把pstring声明为char *的别名，也就是说pstring的基本类型是指针
const pstring cstr = 0;
//const是对指针类型的修饰，所以这句话意思是cstr是指向char的常量指针
const pstring *ps;
//ps是指向（指向char的指针）的常量指针
```

#### 2.5.2 `auto`类型说明符

`auto`让编译器替我们分析表达式所属的类型（推断）

使用`auto`可以在一条语句中声明多个变量，但是一条声明语句中只能有一个基本数据类型，所以该**语句中所有变量的初始基本数据类型必须都一样**。

**对于顶层`const`来说**，`auto`会自动忽略，只保留底层`const`。

如果需要保留顶层`const`，必须要显式地指出`const auto`。

#### 2.5.3 `decltype`类型指示符

选择并返回操作数的数据类型

**注意**：在`decltype`处，引用**不是**其所指对象的同义词，而是引用本身（所以用引用作为某个变量类型的时候必须初始化）

* `decltype`和引用

  ```c++
  int i = 42, *p = &i, &r = i;
  decltype(*p) c; //不合法，c是int &，需要初始化
  ```

  表达式是**解引用**，那么`decltype`将得到**引用类型**

`decltype((variable))`的结果永远是**引用**

### 2.6 自定义数据结构

#### 2.6.1 定义`Sales_data`类型

```c++
struct Sales_data  //类名
//类体
{ 
    std::string bookNo;
    unsigned units_sold = 0; //允许提供初始值
    double revenue = 0.0;
};  //后面可以直接紧跟变量名，但是最好
```

**类体右侧的表示结束的花括号后必须写一个分号。**

#### 2.6.2 使用`Sales_data`类

用点操作符读入对象的数据成员

#### 2.6.3 编写自己的头文件

预处理器：是在编译之前执行的一段程序，可以部分地改变我们所写的程序。

头文件保护符：依赖于预处理变量（已定义`#ifdef`/未定义`#ifndef` `#endif`）

可以防止重复包含。

**注意**：预处理变量无视关于作用域的规则



## chap3 字符串、向量和数组

`string`：可变长的字符序列

`vector`：某种给定类型对象的可变长序列

### 3.1 命名空间的using声明

* 每个名字都需要独立的`using`声明

```C++
#include<iostream>
using std::cin;
using std::cout;using std::endl;
```

* 头文件不应该包含`using`声明

### 3.2 标准库类型`string`

使用前需要：

```c++
#include <string>
using std::string;
```

#### 3.2.1 定义和初始化`string`对象

```c++
#include <string>
using std::string;
//初始化string的方式
string s1;  //默认初始化，空串
string s2(s1);  //s2是s1的副本，直接初始化
string s2 = s1;  //等价于s2(s1)，拷贝初始化
string s3("value");  //s3是字面值“value”的副本，不包括字面值最后的空字符
string s3 = "value";
sting s4(10, 'c');  //把s4初始化为由连续n个字符c组成的串
```

* 用等号初始化一个变量，实际上执行的是拷贝初始化
* 不使用等号的话，执行的是直接初始化

*尽管`string s2(s1);`和`string s2=s1;`效果是一样的，但是前者是直接初始化，后者是拷贝初始化*

#### 3.2.2 `string`对象上的操作

* **注意：**在执行读取操作时，`string`对象会自动忽略开头的空白（空格符、换行符、制表符）

* 使用`getline`读取一整行

  `getline`只要一遇到换行符就结束读取操作并且返回结果，**换行符也是被读取的**

  但是一旦用`string`保存这个字符串，会丢弃换行符

* `string`的`empty`和`size`操作

  `empy`更像是一个`is_empty`的方法，返回布尔值，如果是空的话就返回`True`

  `size`操作返回的是一个`size_type`的类型。是一个无符号类型。

  **如果一条表达式中已经有了`size()`函数就不要再使用`int`了，这样可以避免混用`int`和`unsigned`可能带来的问题**

* 字面值和`string`对象相加

  按顺序往后加，加号左右至少有一个是`string`。比如说：

  ```c++
  #include <string>
  using std::string;
  
  sting1 = "Hello";
  string2 = string1 + ","; //合法
  string3 = string1 + "," + “World”;  //合法，相当于结合了一下
  string4 =  "," + “World” + string1;  //非法，两个字面值不能直接相加
  ```

**字符串字面值并不是标准库类型`string`的对象**

#### 3.2.3 处理`string`对象中的字符

* 建议使用`C++`标准库，也就是用`cname`的头文件而不是`name.h`，因为`cname`中的变量是一定包含在`std`变量空间的，而`name.h`中的变量则不一定

* 处理每个字符：

  使用基于范围的`for`语句

  ```c++
  string str("some thing");
  for (auto c : stc)
      cout << c << endl;
  ```

  **auto:** 让编译器通过初始值来推算变量的类型。`auto`定义的变量必须有初始值。

* 使用范围`for`语句改变字符串中的字符

  **必须把循环变量定义成引用类型**

* 如果只处理一部分字符的话，需要确保**`string`对象非空**，`string`对象的下标必须大于等于0小于`s.size()`。

* 使用下标时必须确保其在合理范围之内，也就是说下标必须大于等于`0`而小于字符串的`size()`的值。一种简便易行的方法是总是设置下标的类型为`string::size_type`，这样可以确保下标不会小于`0`。此时只要保证下标小于`size()`的值就可以了。

* 使用下标执行随机访问

  对于不打算改变值的量可以设置为常量`const`

### 3.3 标准库类型`vector`

* 模板
  * 类模板（`vector`是一个类模板）
  * 函数模板

由模板创建类或者函数的过程称为**实例化**



*`vector`类似一个容器，可以装各种类型，因此使用这个模板的时候需要指出具体是什么类型，比如`vector<int>`*；

`vector`能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的`vector`

#### 3.3.1 定义和初始化`vector`对象

* 列表初始化：

  ```c++
  using std::vector;
  vector<string> articles = {"a", "an", "the"};
  ```


初始化方式一般互相等价，但是有以下三种例外：

1. 使用拷贝初始化的时候，只能提供一个初始值
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或者使用花括号的形式初始化
3. 如果提供的是初始元素值的列表，则只能把初始值都**放在花括号里**进行列表初始化，而不能放在圆括号里。

* 区分是列表初始值还是元素数量：

  ```c++
  vector<int> v1(10);
  //v1有10个元素，每个元素都是0
  vector<int> v2{10};
  //v2有1个元素，为10
  
  vector<int> v3(10, 1);
  //v3有10个元素，每个元素都是1
  vector<int> v4{10, 1};
  //v4有2个元素，为10和1
  ```

  也即：

  圆括号：提供的值是用来构造`vector`对象的

  花括号：列表初始化该`vector`对象

**`vector<int> v1;`和`vector<int> v2(10);`有一点不一样，后者会有初始值0，而前者是一个空的`vector`**

#### 3.3.2 向`vector`对象中添加元素

`vector`的成员函数`push_back`可以实现往已有的`vector`中添加元素，位置是push到尾部。

**注意：**`vector`对象能高效增长，只要`vector`里的元素不是全都一样的，那就应该采用“先创建一个空的`vector`，再在运行时往里添加元素”的方式，不过这种方式不能采用范围`for`语句。（原因待补充）

#### 3.3.3 其它`vector`操作

成员函数`size`返回`vector`对象中元素的个数，返回值类型是由`vector`定义的`size_type`类型。在使用`size_type`之前，要指定其类型：

```c++
vector<int>::size_type  //正确
vector::size_type  //错误
```

`vector`对象和`string`对象的下标运算符可用于访问已存在的元素，而不能用于添加元素。

**试图用下标的形式去访问一个不存在的元素会在运行时产生一个不可预知的值——buffer overflow。**确保下标合法的一种有效手段是尽可能使用范围`for`

### 3.4 迭代器介绍

支持迭代器的数据类型：容器（除了`vector`之外，C++还定义了几种其它容器）；`string`

*不过不是所有容器都同时支持迭代器和下标访问*

迭代器有效的情形：

1. 指向某个元素
2. 指向容器中尾元素的下一位置

#### 3.4.1 使用迭代器

（拥有迭代器的数据类型）也会拥有（返回迭代器的成员）：

`begin`：返回指向容器/`string`对象的第一个元素/字符的迭代器

`end`：返回指向容器/`string`对象的**尾元素的下一位置**的迭代器，也叫尾后迭代器

*`end`返回的迭代器并不实际指示某个元素，所以不能对齐进行递增或者解引用的操作*

**特殊情形**：如果容器为空，那么`begin`和`end`返回的是同一个迭代器，都是尾后迭代器（*可以利用这个特性来判断容器是否为空，防止一些不合法的操作*）

一般不在意迭代器类型，所以可以用`auto`关键字

* 迭代器运算符

  <img src="C:\Users\韦澜\AppData\Roaming\Typora\typora-user-images\image-20221012153058283.png" alt="image-20221012153058283" style="zoom: 67%;" />

  尤其常用的应该是第一项：

  `*iter`返回迭代器`iter`所指元素的引用

  **如果试图解引用一个非法迭代器/尾后迭代器，那都是未被定义的。**

* 将迭代器从一个元素移动到另外一个元素

  **写`for`循环的时候尽量使用`!=`，而不要使用`<`。因为所有标准库容器的迭代器都定义了`==`和`!=`，但是大多数都没有定义`<`**

* 迭代器类型

  不需要知道迭代器的精确类型（就像`string`和`vector`的`size_type`的数据类型一样）

  ```c++
  vector<int>::iterator it;  //it可以读写vector<int>的元素
  string::iterator it2;  //it2可以读写string对象中的元素
  
  vector<int>::const_iterator it3;  //const_iterator只能读元素，不能写元素
  string::const_iterator it4;
  ```

* `begin`和`end`运算符

  返回的具体类型由对象是否是常量决定，有时候想要一个常量类型的迭代器，可以用`cbegin`和`cend`这两个成员函数

* 结合解引用和成员访问操作

  箭头运算符：`->`

  `it->mem`等价于`(*it).mem`

**凡是用了迭代器的循环体，都不要向迭代器所属的容器添加元素**

> 具体来说，就是`vector`可以动态增长的这一特性有一定的副作用：1）不能在范围`for`循环中向`vector`对象添加元素；2）任何一种可能改变`vector`对象容量的操作（比如`push_back`）都会使得迭代器失效

#### 3.4.2 迭代器运算

| `iter + n`           |                                                              |
| -------------------- | ------------------------------------------------------------ |
| `iter - n`           |                                                              |
| `iter += n`          | 复合语句，将向前移动过的迭代器的结果再赋给这个迭代器         |
| `iter -= n`          |                                                              |
| `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离；参与运算的两个迭代器必须**指向的是同一个容器中的元素或者尾元素的下一位置** |
| `>`、`<`、`>=`、`<=` |                                                              |

**注**：两个迭代器之间的距离指的是**右侧的迭代器向前移动多少位置就能追上左侧的迭代器**，类型是**`difference_type`**，是带符号的类型。

* 使用迭代器运算

  例子：二分法查找（给定的序列是**有序的**）

```c++
auto beg = text.begin();
auto end = text.end();
auto mid = (end - begin) / 2 + text.begin();
while (mid != end && mid != sought)
{
    if (sought < *mid)
    	end = mid;
    else
        begin = mid;
    mid = begin + (begin + end) / 2;
}
```

**tips:** 关于这个`mid`怎么取，可以取成`mid = (begin + end) / 2`也可以取成上面那个例子那样，但是后者更好一点，因为前者在`begin`和`end`都很大的时候很容易溢出。

### 3.5 数组

**和`vector`有一定相似之处，但是如果不确定元素的确切个数的话，请使用`vector`**。

#### 3.5.1 定义和初始化内置数组

* 字符数组的特殊性

  ```c++
  char a1[] = {'C', '+', '+'}; //列表初始化，没有空字符
  char a2[] = {'C', '+', '+', '\0'}; //列表初始化，有显式的空字符
  char a3[] = {'C++'}; //自动添加空字符
  ```

  如果用字符串字面值初始化字符数组的话，要注意末尾会自动补上一个空字符，表示字符串的结尾，所以在定义数组维度的时候要预留一位。

* 不允许拷贝和赋值

  不能直接把数组的内容拷贝给其它数组/为其它数组赋值

* 理解复杂的数组声明

  ```c++
  int *ptrs[10]; //含有10个整型指针的数组
  int &refs[10] = /*  ?  */; //非法，不存在引用的数组
  int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
  int (&arrRef)[10] = arr; //arrRef是一个对有10个整数的数组的引用
  ```

**注：**在主函数内外各定义一个`int`数组，且不进行初始化，那么这两个数组的值是不一样的。在主函数外的`int`数组会被存储到堆里，这个数组的值会被全部初始化为0；在主函数内定义的`int`数组则是存储到栈里，值是不能够确定的。*栈由系统自动分配，速度较快。 但程序员是无法控制的。 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。*

#### 3.5.2 访问数组元素

* 数组下标的类型：`size_t`，这是一种无符号类型，在`stddef`标准库中被定义。*顺便，`vector`的下标类型可以通过vec.size()获取*
* 数组下标需要程序员检查，**及时顺利通过编译并执行，也不能肯定它不包含此类致命的错误**

#### 3.5.3 指针和数组

数组名字->指向数组首元素的指针

所以，在一些情况下数组的操作实际上是指针的操作。

**例外：**当使用`decltype`关键字时，上述转换不会发生。也就是说：`int arr[] = {0, 1, 2, 3, 4}; decltype(arr) arr2 = {4, 3, 2, 1, 0};`语句中，得到的类型是一个维度为5的整型数组。

* 指针也是迭代器：

  指向数组第一个元素的指针；

  指向数组尾元素的下一位置的指针

```c++
for (int *b = arr; b != &arr[10]; ++b)  // arr是维度为10的数组，不过这里取&arr[10]的写法很容易出错
    cout << *b << endl;
```

* 标准库函数`begin`和`end`

  *和容器中的同名函数很类似，但是数组并不是类类型，所以这两个函数不是成员函数。*

  ```c++
  #include<iterator>
  int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int *beg = begin(ia);
  int *last = end(ia);  //注意不要变量名和函数名重名
  ```

  和尾后迭代器类似的，尾后指针也**不能进行解引用和递增的操作**。

* 指针运算

  和迭代器的运算完全一样。

  两个指针相减的结果的类型是`ptrdiff_t`，定义在`cstddef`中，是带符号的类型。

  指针运算同样适用于空指针和**所指对象并非数组的指针**

  **必须注意的：**在比较两个指针的时候，必须保证这两个指针指向同一个对象

* 解引用和指针运算的交互

* 下标和指针

  对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

  ```c++
  int ia[] = {0, 2, 4, 6, 8};
  int *p = &ia[2];
  int j = p[1];  //p[1]等价于*(p + 1)
  int k = p[-2]; //p[-2]等价于*(p - 2) = a[0]
  ```

  **内置的下标可以是负值**，是带符号的类型。

#### 3.5.4 `C`风格字符串

`C`风格字符串：存放在字符数组中，**并以空字符结束（`'\0'`）**

* `C`标准库`String`函数

  `#include <cstring>`

  `strlen(p)`

  `strcmp(p1, p2)`：比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值

  `strcpy(p1, p2)`

  `strcat(p1, p2)`

* 比较字符串

```c++
// 比较string对象
string s1 = "A string example";
string s2 = "A different string";
if (s1 < s2) //false
    continue;

// 比较C风格字符串
const char ca1[] = "A string example";
const char ca2[] = "A different string";
//if (ca1 < ca2) //两个指向不同对象的指针不能进行比较
if (strcmp(ca1, ca2))
    continue;
```

* 目标字符串的大小由调用者指定

  ```c++
  #include <string>
  #include <cstring>
  string largeStr = s1 + " " + s2;
  
  strcpy(largeStr, ca1);
  strcat(largeStr, " ");
  strcat(largeStr, ca2);
  //必须估计largeStr所需要的内存空间，而且一旦largeStr所存的内容改变，就必须重新检查其空间是否足够
  ```

#### 3.5.5 与旧代码的接口

`c_str`：`string`提供的成员函数，可以把`string`类的对象转换为`C`风格的字符数组

```c++
string s("Hello World!");
char *str = s; //错误，不能使用string来初始化char*(字符类型的数组，C风格的字符串)
const char *str = s.c_str(); //正确
```

**如果后续改变了s的值，之前返回的`c_str()`数组就有可能失效，所以建议先做好保存**

* 使用数组初始化`vector`对象

  ```c++
  int int_arr[] = {0, 1, 2, 3, 4, 5};
  vector<int> ivec(begin(int_arr), end(int_arr));
  ```


使用指针和数组很容易出错，尽量使用`vector`和迭代器；避免使用基于数组的字符串，尽量使用`string`。

### 3.6 多维数组

多维数组实际上就是**数组的数组**：

```c++
int ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组
int arr[10][20][30] = {0};
// 大小为10的数组，它的每个元素都是大小为20的数组，这些数组的元素是含有30个整数的数组
```

对于二维数组来说，把第一个维度称为行，第二个维度称为列。

初始化的时候，内层嵌套的花括号可以省略：

```c++
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};
// 等价于
int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
```

也可以只初始化部分元素：

```c++
int ia[3][4] = {{0}, {4}, {8}}; //只初始化了每一行的首元素。其它未列出的元素执行默认值初始化。
int ix[3][4] = {0, 3, 6, 9}; //只初始化了第一行元素
```

* 多维数组的下标引用

```c++
int (&row)[4] = ia[1]; //把ia的第一行元素与row绑定，row是一个有4个整型元素的数组的引用
```

使用两层嵌套的`for`处理多维数组的元素

```c++
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];
for (size_t i = 0; i != rowCnt; i++)
    for (size_t j = 0; j != colCnt; j++)
        ia[i][j] = i * colCnt + j;
```

* 使用范围`for`语句处理多维数组

```c++
size_t cnt = 0;
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];
for (auto &row : ia)
    for (auto &col : row)
    {
        col = cnt;
        ++cnt;
    }
```

**注意**：在上面这段程序中，将外层循环的控制变量声明成了引用类型，这是为了**避免数组被自动转成指针**。所以要使用范围`for`语句处理多维数组，**除了最内层的循环外，其它所有循环的控制变量都应该是引用类型**。

* 指针和多维数组
* 类型别名简化多维数组的指针

```c++
using int_array = int[4]; //类型别名的声明
typedef int int_array[4]; //等价的typedef声明
for (int_array *p = ia; p != ia + 3; ++p){
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
//这一段输出了一个3*4的数组内容
```

*终于到第四章了呜呜呜呜*

## chap4  表达式

### 4.1 基础

#### 4.1.1 基本概念

* 运算符
	* 一元运算符：作用于一个运算对象的运算符（取地址符`&`/解引用符`*`）
	* 二元运算符：作用于两个运算对象的运算符（`==`/`!=`等）
	* 三元运算符
	* **函数调用**也是一种**特殊的运算符**，对运算对象的数量没有限制

* 左值和右值

  当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）；

  在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用。

#### 4.1.2 优先级与结合律

**复合表达式**：含有两个或者多个运算符的表达式。

* 括号无视优先级与结合律

#### 4.1.3 求值顺序

在书写复合表达式的时候：

1. 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求
2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象（重要例外：`*++iter`）

### 4.2 算术运算符

```c++
// 一元负号运算符对运算对象取负后，返回其提升后的副本
// 需要注意的是，bool型不应该参与运算
int i = 1024;
int k = -1; //负号优先级最高，k的值是-1024
bool b = true;
bool b2 = -b; //b2的值还是true。原因：b参与运算时变成整型1，取负号变成-1，是非零的，所以b2的值当然是true
```

* 取余运算符：

  要求参与取余运算的运算对象必须是整数类型

  `m%n`：`(m / n) * n + m % n` = `m`

**C++11新标准**：商一律向0取整；负号可以提在最外面。

### 4.3 逻辑和关系运算符

* 逻辑与和逻辑或运算符

  逻辑与和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值——短路求值：

  * 逻辑或：左侧为假时才求右侧运算对象
  * 逻辑与：左侧为真时才求右侧运算对象

  **把元素声明成引用的好处：可以避免对元素的拷贝（利于那些对象可能比较大的情况）**

* 逻辑非运算符

* 关系运算符

  都满足左结合律

* 相等性测试与布尔字面值

  **进行比较运算的时候除非比较的对象是布尔类型，否则不要使用布尔字面值`true`和`false`作为运算对象**

### 4.4 赋值运算符

赋值**运算的结果是它的左侧运算对象**，是一个左值。**如果赋值运算符的左右两个运算对象类型不同，则右侧对象将转换成左侧运算对象的类型。**

```c++
int k;
k = 3.14; // 会发生一个类型转换，将3.14转换为3后赋值给k
k = {3.14}; // 错误，列表初始化中禁止窄化转换
```

* 赋值运算满足右结合律

```c++
int ival, jval;
ival = jval = 0;
//jval=0先运算，运算结果是被赋值为0的jval，再把这个结果赋给ival。所以这个语句运算的结果是ival和jval都被赋值成0
```

* 赋值运算优先级较低

  在条件语句中，赋值部分通常应该加上括号

* 复合赋值运算符

  位运算符也有相应的复合赋值形式：

  `<<=`	`>>=`	`&=`	`^=`	`|=`

  复合运算符只求值一次，使用普通的运算符则求值两次

### 4.5 递增和递减运算符

优先使用前置版本递增运算符

* 在一条语句中混用解引用和递增运算符

  ```c++
  auto pbeg = v.begin();
  while (pbeg != v.end() && *beg >= 0)
      cout << *pbeg++ << endl; // 输出当前值并将pbeg向前移动一个元素
  // 后置递增运算的优先级高于解引用的优先级，所以先得到pbeg++，保存移动后的pbeg，但是解引用的时候使用的是递增之前的指针的副本
  ```

  **在解引用的时候尽量避免使用前置递增，因为很容易导致解引用一个不存在的地址**

* 运算对象可按任意顺序求值

  由于递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。（*左右尽量不要改变同一个运算对象的值，很容易产生未定义的赋值语句*）

### 4.6 成员访问运算符

### 4.7 条件运算符

```c++
string finalgrade = (grade < 60) ? "fail" : "pass";
```

当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。

+ 嵌套条件运算符

```c++
finalgrade = (grade > 90) ? "high pass"
							:(grade < 60) ? "fail" : "pass";
```

​	条件运算的嵌套最好不要超过两到三层

* 在输出表达式中使用条件运算符

  **条件运算符的优先级非常低**，在长表达式中嵌套条件运算子表达式时，通常需要在它两端加上括号。

### 4.8 位运算符

**建议仅将位运算符用于处理无符号类型**

```c++
unsigned char b = 0233;
// 由于char在机器内部被识别为ASCII码，所以实际上char也是一种整数，只不过该类型所允许的数据的最大长度与int不同而已。（更准确地来说，char一般占8位，而int一般占32位。）
```

* 移位运算符

  右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则会产生未定义的行为。

  移出边界之外的位会被舍弃。

* 位求反运算符

  将运算对象逐位求反

区别一下位运算符与逻辑运算符：

位与：`&`	逻辑与：`&&`

位或：`|`	逻辑或：`||`

位求反：`~`	逻辑非：`！`

* 使用位运算符

* 移位运算符（又叫IO运算符）满足左结合律

```c++
cout << "hi" << "there" << endl;
// 等价于
((cout << "hi") << "there") << endl;
```

使用位运算符的时候会先把*small integer*转换成*larger integer*

### 4.9 `sizeof`运算符

返回的是**一条表达式或一个类型名字所占的字节数**

`sizeof`**并不实际计算其运算对象的值**，因此`sizeof *p`可以得到`p`指向的运算对象的类型大小（即使`p`可能是一个无效的指针）

* 运算结果：

  * 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1

  * 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小

  * 对指针执行`sizeof`运算得到指针本身所占空间的大小

    *注：在32位系统上，不管指针p指向的是整型数据，还是字符型数据，short型数据，long型数据等，指针p本身所占的内存字节数均为4。也就是要使用4个字节的大小来存储变量p的值。*

  * 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需要有效

  * 对数组执行`sizeof`运算得到整个数组所占空间的大小，`sizeof`运算不会把数组转换成指针来处理

  * 对`string`对象或者`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 

### 4.10 逗号运算符

逗号运算符还有两个运算对象，按照从左往右的顺序依次求值。

首先对左侧的表达式求值，然后将求值结果丢弃掉。**真正的结果是右侧表达式的值**。

### 4.11 类型转换

隐式转换：自动执行，无须程序员的介入，有时甚至不需要程序员了解

```c++
int ival = 3.541 + 3;
// 在这个例子中，会发生隐式转换。
// 隐式转换会尽量避免损失精度，所以会先把int类型转换成double。
// 右边得到6.541。接下来进行初始化，左边的类型为int，所以double转为int，最终结果为6
```

发生隐式转换的场合：

* 在大多数表达式中，比`int`类型小的整数值首先提升为较大的整数类型
* 在条件中，非布尔值转换成布尔类型
* 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
* 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
* 函数调用（chap 6）

#### 4.11.1 算术转换

运算符的运算对象将转换成最宽的类型。

* 整形提升：把小整数类型转换成较大的整数类型

  `bool`、`signed char`、`unsigned char`、`short`、`unsigned short`只要所有可能的值都能存在`int`里，就会提升成`int`，否则提升成`unsigned int`

  较大的`char`类型提升成`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中最小的一种类型

* 无符号类型的运算对象

#### 4.11.2 其它隐式类型转换

* 数组转换成指针：指针指向数组首地址
* 指针的转换：`0` `nullptr`
* 转换成布尔类型
* 转换成常量 `const`
* 类类型定义的转换 

```c++
string s, t = "a value"; // 字符串字面值->string
while (cin >> s) /* */ // istream -> bool
```

#### 4.11.3 显式转换

**虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。**

* 命名的强制类型转换

  `static_cast`:

  只要不包含底层`const`

  ```c++
  double slope = static_cast<double>(j) / i;
  ```

  用途：把较大的算术类型赋值给较小的类型；编译器无法自动执行的类型转换

  `const_cast`:

  **只能改变运算对象的底层`const`**

*p145-147 强制略了*

### 4.12 运算符优先表

## chap5 语句

### 5.1 简单语句

表达式语句：

```c++
ival + 5;
cout << ival;
```

空语句：

```c++
;
```

*使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。*

**别漏写分号，也别多写分号：**

```c++
while (iter != svec.end()) ; // 循环体变成了空语句
	++iter;
```

复合语句：

```c++
{ } // 空块 等价于 空语句，不以分号作为结束
```

### 5.2 语句作用域

可以在`if`、`switch`、`while`、`for`语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见。

### 5.3 条件语句

#### 5.3.1 `if`语句

* 悬垂`else`：

  `if`和`else`如何匹配的问题叫做悬垂`else`。`C++`中规定`else`与离它最近的尚未匹配的`if`匹配。

* 使用花括号控制执行路径

  **想要使`else`分支和外层的`if`语句匹配起来，可以在内层`if`语句的两端加上花括号，使其成为一个块。**

#### 5.4.2 `switch`语句

```c++
char ch;
while(cin >> ch){
    switch (ch){
        case 'a':
            ++aCnt;
            break;
        case 'e':
            ++eCnt;
            break;
        case 'i':
            ++iCnt;
            break;
        case 'o':
            ++oCnt;
            break;
        case 'u':
            ++uCnt;
            break;
    }
}

```

`case`关键词和它对应的值一起被称为`case`标签。**`case`标签必须是整型常量表达式**

* `Switch`内部的控制流

  一旦某个`case`标签匹配成功，将**从该标签开始往后顺序执行所有`case`分支**

  *一般在标签分支后面都要加上`break`，如果没写`break`，请加注释说明*

* 漏写`break`容易引发缺陷

* `default`标签

  如果没有任何一个`case`标签能匹配上`switch`表达式的值，程序将执行紧跟在`default`标签后面的语句。

  如果以一个空的`default`标签作为结束，则该`default`标签后面必须跟上一条空语句或一个空块

* `switch`内部的变量定义

  不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。
  
  *在某个分支内定义变量是可以的，但是不能在这里初始化之后又在另一个分支上使用*

### 5.4 迭代语句

#### 5.4.1 `while`语句

定义在`while`条件部分或者`while`循环体内的变量每次迭代都经历从创建到销毁的过程

#### 5.4.2 传统的`for`语句

* 传统的`for`循环的执行流程

```c++
for (initializer; condition; expression)
    statement
```

​		`initializer`->判断`condition`->循环体->`expression`

* `for`语句头中的多重定义

  只能有一条声明语句，所以如果要定义多个变量的话，基础类型必须相同。

* 省略`for`语句头的某些部分

  

#### 5.4.3 范围`for`语句

```c++
for (declaration : expression)
    statement
```

`expression`：拥有能返回迭代器的`begin`和`end`成员

比如：初始值列表、数组、`string`、`vector`

**注意**：之前说过不能用范围`for`语句增加`vector`对象或者其它容器的元素，因为在范围`for`语句中预存了`end()`的值，一旦修改元素数量以后，这个值就失效了。

#### 5.4.4 `do while`语句

```c++
do 
    statement;
while (condition); //这里有一个分号表示do while语句的结束
```

**至少执行一次循环**

由于`do while`先执行语句/块，后判断条件，所以不允许在条件部分定义变量。

### 5.5 跳转语句

`break`、`continue`、`goto`、`return`

#### 5.5.1 `break`语句

作用范围：**最近**的循环/`switch`

#### 5.5.2 `continue`语句

只有在迭代语句内部才可以用。

与`break`相同：出现在嵌套循环中的`continue`语句也仅作用于离它最近的循环

与`break`不同：只有当`switch`嵌套在迭代语句内部时，才能在`switch`里使用`continue`

中断当前的迭代，但是仍然继续执行循环

#### 5.5.3 `goto`语句

```c++
goto label;
// label是用于标识一条语句的标识符
// 比如：
end: return; // goto end;
```

### 5.6 `try`语句块和异常处理

`throw`：异常检测，表示遇到了无法处理的问题

`try`：+`catch`子句，异常处理

异常类：传递异常的具体信息

#### 5.6.1 `throw`表达式

```c++
#include <stdexcept>
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
cout << item1 + item2 << endl;
//runtime_error必须初始化
```

抛出异常将**终止当前的函数**，并把控制权转移给能处理该异常的代码。

#### 5.6.2 `try`语句块

```c++
try {
    program-statements
} catch (exception-declaration) {
    handle-statements
} catch (exception-declaration) {
    handle-statements
} // ...
```

* 函数在寻找处理代码的过程中退出

  与函数调用链相反，异常被抛出时，首先搜索抛出该异常的函数。

* 编写异常安全的代码非常困难

#### 5.6.3 标准异常

异常类：

* `exception`：定义了最通用的异常类`exception`。它只报告异常的发生，不提供任何额外信息。

* `stdexcept`：

  ![image-20221125201002108](C:\Users\韦澜\AppData\Roaming\Typora\typora-user-images\image-20221125201002108.png)

* `new`：定义了`bad_alloc`

* `type_info`：定义了`bad_cast`



初始化：

`exception`、`bad_alloc`、`bad_cast`只允许默认初始化；

其他类型必须用`string`或者`C`风格字符串初始化

成员函数：

只有`what`，返回`const char*`
