# C++ Primer 5e

## chap1 开始

### 1.1 编写一个简单的C++程序

* `main`函数的返回类型必须是`int`，一般来说，返回0表示程序运行成功，非0的返回值的含义由系统定义，用来指出错误类型。

​		**一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。**

* IDE：将编译器与其他程序创建和分析工具包装在一起，集成开发环境

### 1.2 初识输入输出

* 流：随着时间的推移，字符是顺序生成或消耗的

* `istream`类型的对象：`cin`

  `ostream`类型的对象：`cout`、`cerr`（输出警告和错误消息，标准错误）、`clog`（输出程序运行时的一般性信息）

* `<<`运算符接受两个运算对象，左侧运算对象必须是一个`ostream`对象，右侧的运算对象就是要打印的值。此运算符将给定的值写到给定的`ostream`对象中。输出运算符的计算结果就是其左侧运算对象。

  下面两段代码就是等价的：

  第一段：

  `(std::cout << 'Enter two numbers:') << std::endl;`

  第二段：

  `std::cout << 'Enter two numbers:';`

  `std::out << std::endl;`

  注意：

  这里的`std::`表示后面的变量从属于`std`这个变量空间。`::`这个符号表示作用域。不同的变量空间中的变量互不影响，可以自己定义变量空间；如果在源文件开头写了`using namespace std;`就不需要再强调变量`cin`属于`std`了。

  同时，`endl`是一个被称为操纵符的特殊值。写入`endl`的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。如果想通过`print`来观察程序运行过程的话，应该保证缓冲区一直被刷新。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。** 

### 1.3 注释简介

* 注释不能嵌套

### 1.4 控制流

* `while`语句

* `for`语句

## chap2 变量和基本类型

### 2.1 基本内置类型

#### 2.1.1 算数类型

字节（byte）：可寻址的最小内存块

字（word）：存储的基本单元

大多数机器的字节由8比特构成；字有4字节或者8字节

`float`（1个字，32比特来表示）和`double`分别有7和16个有效位

* 带符号类型和无符号类型

  字符型被分为了三种：`char`、`signed char`、`unsigned char`。`char` 会表现为带符号/无符号中的任意一种

* 在算术表达式中不要使用`char`或者`bool`。因为类型`char`在一些机器上有符号
* 执行浮点数运算选用`double`。

####  2.1.2 类型转换

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值**总数**取模后的余数。
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。**此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据**
* 如果循环的条件中，用来计数的变量设置成了无符号数，要注意检查，小心死循环：

​		![image-20220831201009234](C:\Users\韦澜\AppData\Roaming\Typora\typora-user-images\image-20220831201009234.png)

* **注意：**切勿混用带符号类型和无符号类型

#### 2.1.3 字面值常量

啥是字面值常量？一看就知道是什么类型的常量。

* 0开头的整数表示八进制数，以0x或0X开头的代表十六进制数

* 字符和字符串字面值：
  * 字符串字面值：每个字符串结尾处添加一个空字符`'\0'`，因此实际长度要比内容+1
  * 区别`'a'`和`"A"`，前者长度是1，后者长度是2（因为是字符串）
  * 如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分割，则它们实际上是一个整体

* 转义序列

* 指针字面值：`nullptr`

注意：

`3.14`：`double`

`3.14f`：`float`

*也就是说小数的数据类型默认是`double`*

### 2.2 变量

#### 2.2.1 变量定义

> 本书认为对象是具有某种数据类型的内存空间。在使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或是否只读。

**初始化和赋值的区别：**

初始化：创建变量时赋予其一个初始值；

赋值：把对象的当前值擦除，而以一个新值来替代

*列表初始化*将在第三章继续介绍。

**定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。**（如果试图拷贝或以其他形式访问未定义的值，将引发错误）**类的对象如果没有显式地初始化，则其值由类确定。**（有些类规定必须要显式地初始化，否则会出错）

*练习*

`std::cin >> int input_value;`  // 非法，先定义一个整型变量，然后用外部输入进行赋值

`int i = {3.14};`   // 非法，浮点数无法为整型变量做初始化 

`double salary = wage = 9999.99;` // 非法，试了一下，编译的时候会报错，编译器认为`wage`是未被定义的变量

`int i = 3.14;`  // 强制类型转换，输出`i`的值为3

**初始化每一个内置类型的变量**

#### 2.2.2 变量声明和定义的关系

* 声明：名字为程序所知，规定了变量的类型和名字
  * 在变量前添加关键词`extern`，并且不要显式初始化变量（显式初始化会使得变量被定义，就不再是声明了）
* 定义：创建与名字关联的实体，申请存储空间，也可能为变量赋一个初始值
  * 变量**能且只能被定义一次**，但是可以被多次声明

**注意**：类似`int j;`的写法是既声明又定义

C++是一种静态类型(statically typed)语言，也就是说在编译阶段进行类型检查(type checking)

#### 2.2.3 标识符

* Yes:
  * 字母/下划线+数字
  * 对大小写敏感

* No:
  * 不能连续出现两个下划线
  * 不能以下划线紧连大写字母开头
  * 定义在函数体外的标识符不能以下划线开头

#### 2.2.4 名字的作用域

有效区域：始于**名字的声明语句**；结束于**所在作用域末端**

全局作用域；块作用域

```c++
#include <iostream>
using namespace std;
int main()
{
    int i = 100, sum = 0;
    for (int i = 0; i != 10; ++i)
        sum += i;
    cout << i << " " << sum << endl;
    return 0;
}
```

运行结果：

```
100 45
```

**注意：**`for`循环中`i`的作用域在line 7就结束了。所以最后输出的`i`的值是第五行定义的。

### 2.3 复合类型

#### 2.3.1 引用（&）

* 一般说的引用都是指左值引用
* 引用本身不是一个对象（所以只能绑定一个变量），不能定义引用的引用
* 实际上就是一个别名。如果别名和它要bind的对象类型不符，会发生强制类型转换

#### 2.3.2 指针（*）

* 指针与引用的不同点：
  * 指针本身就是一个对象，允许对指针复制和拷贝，在职者的呢生命周期内可以先后指向几个不同的对象
  * 指针无须在定义时赋初值（*也就是说指针也是一种内置类型。和其它内置类型一样，如果没有初始化的话就会有一个随机的初始值*）

* 取地址符 &
* 解引用符*
* **指针的类型要和它所指向的对象严格匹配**

**在声明语句中，&和*组成复合类型；在表达式中，它们的角色又转变成运算符。**



* 空指针

  建议初始化所有指针，如果实在不清楚指针应该指向何处，就把它初始化为`nullptr`或者`0`。（*虽然C++11里还有NULL可以用，但是尽量不要用*）



* 赋值和指针



* 其他指针操作

  两个类型相同的合法指针，可以用`==`/`!=`来比较：

  两个指针相等：

  * 两个指针存放的地址值相同

    他们都为空

    都指向同一个对象

    都指向了同一个对象的下一个地址

  * 一个指针指向某对象/另一个指针指向另外对象的下一地址



* `void*`指针

  不能直接操作`void*`指针所指的对象，因为不知道这个对象到底是什么类型（*以`void*`*的视角来看，内存空间仅仅是内存空间，没办法访问内存空间中所存的对象）