# C++ Primer 5e

## chap1 开始

### 1.1 编写一个简单的C++程序

* `main`函数的返回类型必须是`int`，一般来说，返回0表示程序运行成功，非0的返回值的含义由系统定义，用来指出错误类型。

​		**一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。**

* IDE：将编译器与其他程序创建和分析工具包装在一起，集成开发环境

### 1.2 初识输入输出

* 流：随着时间的推移，字符是顺序生成或消耗的

* `istream`类型的对象：`cin`

  `ostream`类型的对象：`cout`、`cerr`（输出警告和错误消息，标准错误）、`clog`（输出程序运行时的一般性信息）

* `<<`运算符接受两个运算对象，左侧运算对象必须是一个`ostream`对象，右侧的运算对象就是要打印的值。此运算符将给定的值写到给定的`ostream`对象中。输出运算符的计算结果就是其左侧运算对象。

  下面两段代码就是等价的：

  第一段：

  `(std::cout << 'Enter two numbers:') << std::endl;`

  第二段：

  `std::cout << 'Enter two numbers:';`

  `std::out << std::endl;`

  注意：

  这里的`std::`表示后面的变量从属于`std`这个变量空间。`::`这个符号表示作用域。不同的变量空间中的变量互不影响，可以自己定义变量空间；如果在源文件开头写了`using namespace std;`就不需要再强调变量`cin`属于`std`了。

  同时，`endl`是一个被称为操纵符的特殊值。写入`endl`的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。如果想通过`print`来观察程序运行过程的话，应该保证缓冲区一直被刷新。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。** 

### 1.3 注释简介

* 注释不能嵌套

### 1.4 控制流

* `while`语句

* `for`语句

## chap2 变量和基本类型

### 2.1 基本内置类型

#### 2.1.1 算数类型

字节（byte）：可寻址的最小内存块

字（word）：存储的基本单元

大多数机器的字节由8比特构成；字有4字节或者8字节

`float`（1个字，32比特来表示）和`double`分别有7和16个有效位

* 带符号类型和无符号类型

  字符型被分为了三种：`char`、`signed char`、`unsigned char`。`char` 会表现为带符号/无符号中的任意一种

* 在算术表达式中不要使用`char`或者`bool`。因为类型`char`在一些机器上有符号
* 执行浮点数运算选用`double`。

####  2.1.2 类型转换

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值**总数**取模后的余数。
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。**此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据**
* 如果循环的条件中，用来计数的变量设置成了无符号数，要注意检查，小心死循环：

​		![image-20220831201009234](C:\Users\韦澜\AppData\Roaming\Typora\typora-user-images\image-20220831201009234.png)

* **注意：**切勿混用带符号类型和无符号类型

#### 2.1.3 字面值常量

啥是字面值常量？一看就知道是什么类型的常量。

* 0开头的整数表示八进制数，以0x或0X开头的代表十六进制数

* 字符和字符串字面值：
  * 字符串字面值：每个字符串结尾处添加一个空字符`'\0'`，因此实际长度要比内容+1
  * 区别`'a'`和`"A"`，前者长度是1，后者长度是2（因为是字符串）
  * 如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分割，则它们实际上是一个整体

* 转义序列

* 指针字面值：`nullptr`

注意：

`3.14`：`double`

`3.14f`：`float`

*也就是说小数的数据类型默认是`double`*

### 2.2 变量

#### 2.2.1 变量定义

> 本书认为对象是具有某种数据类型的内存空间。在使用对象这个词时，并不严格区分是类还是内置类型，也不区分是否命名或是否只读。

**初始化和赋值的区别：**

初始化：创建变量时赋予其一个初始值；

赋值：把对象的当前值擦除，而以一个新值来替代

*列表初始化*将在第三章继续介绍。

**定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。**（如果试图拷贝或以其他形式访问未定义的值，将引发错误）**类的对象如果没有显式地初始化，则其值由类确定。**（有些类规定必须要显式地初始化，否则会出错）

*练习*

`std::cin >> int input_value;`  // 非法，先定义一个整型变量，然后用外部输入进行赋值

`int i = {3.14};`   // 非法，浮点数无法为整型变量做初始化 

`double salary = wage = 9999.99;` // 非法，试了一下，编译的时候会报错，编译器认为`wage`是未被定义的变量

`int i = 3.14;`  // 强制类型转换，输出`i`的值为3

**初始化每一个内置类型的变量**

#### 2.2.2 变量声明和定义的关系

* 声明：名字为程序所知，规定了变量的类型和名字
  * 在变量前添加关键词`extern`，并且不要显式初始化变量（显式初始化会使得变量被定义，就不再是声明了）
* 定义：创建与名字关联的实体，申请存储空间，也可能为变量赋一个初始值
  * 变量**能且只能被定义一次**，但是可以被多次声明

**注意**：类似`int j;`的写法是既声明又定义

C++是一种静态类型(statically typed)语言，也就是说在编译阶段进行类型检查(type checking)

#### 2.2.3 标识符

* Yes:
  * 字母/下划线+数字
  * 对大小写敏感

* No:
  * 不能连续出现两个下划线
  * 不能以下划线紧连大写字母开头
  * 定义在函数体外的标识符不能以下划线开头

#### 2.2.4 名字的作用域

有效区域：始于**名字的声明语句**；结束于**所在作用域末端**

全局作用域；块作用域

```c++
#include <iostream>
using namespace std;
int main()
{
    int i = 100, sum = 0;
    for (int i = 0; i != 10; ++i)
        sum += i;
    cout << i << " " << sum << endl;
    return 0;
}
```

运行结果：

```
100 45
```

**注意：**`for`循环中`i`的作用域在line 7就结束了。所以最后输出的`i`的值是第五行定义的。

### 2.3 复合类型

#### 2.3.1 引用（&）

* 一般说的引用都是指左值引用
* 引用本身不是一个对象（所以只能绑定一个变量），不能定义引用的引用
* 实际上就是一个别名。如果别名和它要bind的对象类型不符，会发生强制类型转换

#### 2.3.2 指针（*）

* 指针与引用的不同点：
  * 指针本身就是一个对象，允许对指针复制和拷贝，在职者的呢生命周期内可以先后指向几个不同的对象
  * 指针无须在定义时赋初值（*也就是说指针也是一种内置类型。和其它内置类型一样，如果没有初始化的话就会有一个随机的初始值*）

* 取地址符 &
* 解引用符*
* **指针的类型要和它所指向的对象严格匹配**

**在声明语句中，&和*组成复合类型；在表达式中，它们的角色又转变成运算符。**



* 空指针

  建议初始化所有指针，如果实在不清楚指针应该指向何处，就把它初始化为`nullptr`或者`0`。（*虽然C++11里还有NULL可以用，但是尽量不要用*）



* 赋值和指针



* 其他指针操作

  两个类型相同的合法指针，可以用`==`/`!=`来比较：

  两个指针相等：

  * 两个指针存放的地址值相同

    他们都为空

    都指向同一个对象

    都指向了同一个对象的下一个地址

  * 一个指针指向某对象/另一个指针指向另外对象的下一地址



* `void*`指针

  不能直接操作`void*`指针所指的对象，因为不知道这个对象到底是什么类型（*以`void*`*的视角来看，内存空间仅仅是内存空间，没办法访问内存空间中所存的对象）

#### 2.3.3 理解复合类型的声明

* 定义多个变量

  ```c++
  int* p1, p2; //*是修饰变量的，是类型修饰符，所以p1是指针而p2是整型变量。
  ```

* 指向指针的指针

  用\*的个数区分指针的级别。（所以指向指针的指针应该有两个修饰符\*）

* 指向指针的引用

  ```c++
  int i = 42;
  int *p;
  int *&r = p; //表示r是对指针的引用
  
  r = &i;
  *r = 0;
  ```

  **离变量名最近的符号对变量的类型有最直接的影响；声明符的其余部分用以确定该变量的类型是什么。所以阅读一个比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。**

Ex:

```C++
int i, *p = 0; //这种声明方式只能说明p是一个空指针，
```



### 2.4 `const`限定符

* `const`一旦创建就不能再改变值，所以**必须初始化**。

* 默认状态下，`const`对象仅在文件内有效

  当多个文件中出现了同名的`const`变量时，等同于在不同文件中分别定义了独立的变量

  * 如果希望在多个文件中都能声明并且使用某个`const`变量（共享），可以在声明和定义的时候都在前面添加关键字`extern`

#### 2.4.1 `const`的引用

对常量的引用不能被用作修改它所绑定的对象。

```c++
const int ci = 1024;
const int &ri = ci; //注意对常量的引用得是常量引用（加const）

int &r2 = ci; //这样就是错的，因为r2不是常量引用
```

**常量引用是“对常量的引用”的简称**，因为引用不是对象，没办法让引用本身不变。（不过引用不能再指向别的变量了，所以也算是常量吧）

**引用的类型必须与其所引用的对象类型一致，但是有两个例外：**

1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果可以转成引用的类型即可。尤其是允许把一个**常量引用**绑定非常量的对象、字面值。

```c++
int i = 42;
const int &r1 = i;
const int &r2 = r1;
int &i3 = r1;  //非法
```

2. 

对`const`的引用可能引用一个并非`const`的对象

```C++
#include <iostream>
using namespace  std;

int main() {
    int i = 42;
    const int &r1 = i;  //一个常量引用
    int &r2 = i;
    r2 = 32;
    cout << "i is " << r1 << endl; //32
    cout << "const i is "<< r2 << endl;  //32

    return 0;
}
```

*也就是说可以是某个引用可以设置为常量引用，通过其它途径来改变这个被引用的变量的值*

#### 2.4.2 指针和`const`

**指针的类型必须与其所指向的对象类型一致，但是有两个例外：**

1. 允许令一个指向常量的指针指向一个非常量的对象



* `const`指针：

  ```c++
  int errNumb = 0;
  int *const curErr = &errNumb; //指向int的常量指针
  const double pi = 3.14159;
  const double *const pip = &pi; //指向常量的常量指针
  ```

  常量指针意思是指针本身不变，也就是说指针存储的地址值不会变了，而不是说指针指向的对象值不可改。

对于`const`来说，不管是常量指针还是普通的常量类型，都需要做初始化；

```c++
//下面的哪些初始化是合法的？请说明原因。
int i = -1, &r = 0; //不合法，引用必须初始化
int *const p2 = &i2; //合法，指向int的常量指针
const int i = -1, &r = 0; //合法，允许静态引用直接拿到一个字面值作为引用
const int *const p3 = &i2; //合法，p3是指向const int的常量指针
const int *p1 = &i2; //合法，p1是指向一个类型为const int的指针
const int &const r2; //没见过
const int i2 = i, &r = i; //合法
```

```c++
int i, *const cp; //不合法，cp是一个指向int的常量指针，必须初始化
int *p1, *const p2; //不合法
const int ic, &r = ic; //不合法，ic是一个常量int，必须先初始化
const int *const p3; //不合法，const指针必须初始化
const int *p; //合法，p是一个指向const int的指针
```

```c++
//假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。
i = ic; //合法，常量int可以赋值给int
p1 = p3; //不合法
p1 = &ic; //不合法，类型不符
p3 = &ic; //不合法，p3指向一个const int，同时又是常量指针
p2 = p1; //不合法，p1是普通的整形指针，存储的地址可以赋给一个常量指针
ic = *p3; //不合法，对p3取地址，得到一个const int，但是const int不能改变值
```

#### 2.4.3 顶层`const`

* 顶层`const`：
  * 表示指针本身是一个`const`
  * 可以表示任意的对象是常量

* 底层`const`：
  * 表示指针指向的对象是一个`const`
  * 与指针和引用等复合类型的基本类型部分有关

用于声明引用的`const`都是底层`const`

`int*`可以转换成`const int*`（*也就是普通类型的变量可以赋值给`const`*）

```c++
//对于下面的这些语句，请说明对象被声明称了顶层const还是底层const
const int v2 = 0; //顶层
int v1 = v2; //不是const
int *p1 = &v1, &ri = v1; //不是const
const int *p2 = &v2, *const p3 = &i, &r2 = v2;
//p2底层，p3顶层，r2是引用，所以是底层
```

```c++
//假设已有上一个练习中所作的那些声明，则下面的哪些语句是合法的？
//请说明顶层const和底层const在每个例子中有何体现？
r1 = v2; //拷贝时，v2作为一个顶层const，不受影响
p1 = p2; p2 = p1; //不合法，不都是底层；合法，int*可以转成const int*
p1 = p3; p2 = p3; //不合法，底层不都是const；合法，顶层const
```

#### 2.4.4 `constexpr`和常量表达式

* 常量表达式：

  值**不会改变**并且在**编译过程**就能得到计算结果的表达式。

一个对象/表达式是不是常量表达式由它的数据类型和初始值共同决定，注意以下两个例子：

```c++
int staff_size = 27; 
//虽然27是字面值，是一种常量表达式，但是staff_size的数据类型仅仅是int而非const int，所以并不是常量表达式
const int sz = get_size();
//虽然sz是const，但是它的值要到运行时才能得到，所以也不是常量表达式
```

* `constexpr`变量

  允许将变量声明为`constexpr`类型，以便由编译器来验证变量的值是否是一个常量表达式。

  **声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化**

* 字面值类型

  常量表达式的值需要在编译时就得到计算，因此对声明`constexpr`时用到的类型必须有所限制——字面值类型

* 指针和`constexpr`

  如果在`constexpr`声明中定义了一个指针，那么这个限定符只对指针有效，与指针所指对象无关

  

### 2.5 处理类型

#### 2.5.1 类型别名

`typedef`:

```c++
typedef double wages; //wages就是double
typedef wages base, *p; //wage和base一样（传递），*p=double *
```

别名声明：

```c++
using SI = Sale_item; //SI是Sale_item的别名
```

指针、常量和类型别名：

`const`是对**给定类型的修饰**：

```c++
typedef char *pstring; 
//这句把pstring声明为char *的别名，也就是说pstring的基本类型是指针
const pstring cstr = 0;
//const是对指针类型的修饰，所以这句话意思是cstr是指向char的常量指针
const pstring *ps;
//ps是指向（指向char的指针）的常量指针
```

#### 2.5.2 `auto`类型说明符

`auto`让编译器替我们分析表达式所属的类型（推断）

使用`auto`可以在一条语句中声明多个变量，但是一条声明语句中只能有一个基本数据类型，所以该**语句中所有变量的初始基本数据类型必须都一样**。

**对于顶层`const`来说**，`auto`会自动忽略，只保留底层`const`。

如果需要保留顶层`const`，必须要显式地指出`const auto`。

#### 2.5.3 `decltype`类型指示符

选择并返回操作数的数据类型

**注意**：在`decltype`处，引用**不是**其所指对象的同义词，而是引用本身（所以用引用作为某个变量类型的时候必须初始化）

* `decltype`和引用

  ```c++
  int i = 42, *p = &i, &r = i;
  decltype(*p) c; //不合法，c是int &，需要初始化
  ```

  表达式是**解引用**，那么`decltype`将得到**引用类型**

`decltype((variable))`的结果永远是**引用**

### 2.6 自定义数据结构

#### 2.6.1 定义`Sales_data`类型

```c++
struct Sales_data  //类名
//类体
{ 
    std::string bookNo;
    unsigned units_sold = 0; //允许提供初始值
    double revenue = 0.0;
};  //后面可以直接紧跟变量名，但是最好
```

**类体右侧的表示结束的花括号后必须写一个分号。**

#### 2.6.2 使用`Sales_data`类

用点操作符读入对象的数据成员

#### 2.6.3 编写自己的头文件

预处理器：是在编译之前执行的一段程序，可以部分地改变我们所写的程序。

头文件保护符：依赖于预处理变量（已定义`#ifdef`/未定义`#ifndef` `#endif`）

可以防止重复包含。

**注意**：预处理变量无视关于作用域的规则



## chap3 字符串、向量和数组

`string`：可变长的字符序列

`vector`：某种给定类型对象的可变长序列

### 3.1 命名空间的using声明

* 每个名字都需要独立的`using`声明

```C++
#include<iostream>
using std::cin;
using std::cout;using std::endl;
```

* 头文件不应该包含`using`声明

### 3.2 标准库类型`string`

使用前需要：

```c++
#include <string>
using std::string;
```

#### 3.2.1 定义和初始化`string`对象

```c++
#include <string>
using std::string;
//初始化string的方式
string s1;  //默认初始化，空串
string s2(s1);  //s2是s1的副本，直接初始化
string s2 = s1;  //等价于s2(s1)，拷贝初始化
string s3("value");  //s3是字面值“value”的副本，不包括字面值最后的空字符
string s3 = "value";
sting s4(10, 'c');  //把s4初始化为由连续n个字符c组成的串
```

* 用等号初始化一个变量，实际上执行的是拷贝初始化
* 不使用等号的话，执行的是直接初始化

*尽管`string s2(s1);`和`string s2=s1;`效果是一样的，但是前者是直接初始化，后者是拷贝初始化*

#### 3.2.2 `string`对象上的操作

* **注意：**在执行读取操作时，`string`对象会自动忽略开头的空白（空格符、换行符、制表符）

* 使用`getline`读取一整行

  `getline`只要一遇到换行符就结束读取操作并且返回结果，**换行符也是被读取的**

  但是一旦用`string`保存这个字符串，会丢弃换行符

* `string`的`empty`和`size`操作

  `empy`更像是一个`is_empty`的方法，返回布尔值，如果是空的话就返回`True`

  `size`操作返回的是一个`size_type`的类型。是一个无符号类型。

  **如果一条表达式中已经有了`size()`函数就不要再使用`int`了，这样可以避免混用`int`和`unsigned`可能带来的问题**

* 字面值和`string`对象相加

  按顺序往后加，加号左右至少有一个是`string`。比如说：

  ```c++
  #include <string>
  using std::string;
  
  sting1 = "Hello";
  string2 = string1 + ","; //合法
  string3 = string1 + "," + “World”;  //合法，相当于结合了一下
  string4 =  "," + “World” + string1;  //非法，两个字面值不能直接相加
  ```

**字符串字面值并不是标准库类型`string`的对象**

#### 3.2.3 处理`string`对象中的字符

* 建议使用`C++`标准库，也就是用`cname`的头文件而不是`name.h`，因为`cname`中的变量是一定包含在`std`变量空间的，而`name.h`中的变量则不一定

* 处理每个字符：

  使用基于范围的`for`语句

  ```c++
  string str("some thing");
  for (auto c : stc)
      cout << c << endl;
  ```

  **auto:** 让编译器通过初始值来推算变量的类型。`auto`定义的变量必须有初始值。

* 使用范围`for`语句改变字符串中的字符

  **必须把循环变量定义成引用类型**

* 如果只处理一部分字符的话，需要确保**`string`对象非空**，`string`对象的下标必须大于等于0小于`s.size()`。

* 使用下标时必须确保其在合理范围之内，也就是说下标必须大于等于`0`而小于字符串的`size()`的值。一种简便易行的方法是总是设置下标的类型为`string::size_type`，这样可以确保下标不会小于`0`。此时只要保证下标小于`size()`的值就可以了。

* 使用下标执行随机访问

  对于不打算改变值的量可以设置为常量`const`

### 3.3 标准库类型`vector`

* 模板
  * 类模板（`vector`是一个类模板）
  * 函数模板

由模板创建类或者函数的过程称为**实例化**



*`vector`类似一个容器，可以装各种类型，因此使用这个模板的时候需要指出具体是什么类型，比如`vector<int>`*；

`vector`能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的`vector`

#### 3.3.1 定义和初始化`vector`对象

* 列表初始化：

  ```c++
  using std::vector;
  vector<string> articles = {"a", "an", "the"};
  ```


初始化方式一般互相等价，但是有以下三种例外：

1. 使用拷贝初始化的时候，只能提供一个初始值
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或者使用花括号的形式初始化
3. 如果提供的是初始元素值的列表，则只能把初始值都**放在花括号里**进行列表初始化，而不能放在圆括号里。

* 区分是列表初始值还是元素数量：

  ```c++
  vector<int> v1(10);
  //v1有10个元素，每个元素都是0
  vector<int> v2{10};
  //v2有1个元素，为10
  
  vector<int> v3(10, 1);
  //v3有10个元素，每个元素都是1
  vector<int> v4{10, 1};
  //v4有2个元素，为10和1
  ```

  也即：

  圆括号：提供的值是用来构造`vector`对象的

  花括号：列表初始化该`vector`对象

**`vector<int> v1;`和`vector<int> v2(10);`有一点不一样，后者会有初始值0，而前者是一个空的`vector`**

#### 3.3.2 向`vector`对象中添加元素

`vector`的成员函数`push_back`可以实现往已有的`vector`中添加元素，位置是push到尾部。

**注意：**`vector`对象能高效增长，只要`vector`里的元素不是全都一样的，那就应该采用“先创建一个空的`vector`，再在运行时往里添加元素”的方式，不过这种方式不能采用范围`for`语句。（原因待补充）

#### 3.3.3 其它`vector`操作

成员函数`size`返回`vector`对象中元素的个数，返回值类型是由`vector`定义的`size_type`类型。在使用`size_type`之前，要指定其类型：

```c++
vector<int>::size_type  //正确
vector::size_type  //错误
```

`vector`对象和`string`对象的下标运算符可用于访问已存在的元素，而不能用于添加元素。

**试图用下标的形式去访问一个不存在的元素会在运行时产生一个不可预知的值——buffer overflow。**确保下标合法的一种有效手段是尽可能使用范围`for`

### 3.4 迭代器介绍

支持迭代器的数据类型：容器（除了`vector`之外，C++还定义了几种其它容器）；`string`

*不过不是所有容器都同时支持迭代器和下标访问*

迭代器有效的情形：

1. 指向某个元素
2. 指向容器中尾元素的下一位置

#### 3.4.1 使用迭代器

（拥有迭代器的数据类型）也会拥有（返回迭代器的成员）：

`begin`：返回指向容器/`string`对象的第一个元素/字符的迭代器

`end`：返回指向容器/`string`对象的**尾元素的下一位置**的迭代器，也叫尾后迭代器

*`end`返回的迭代器并不实际指示某个元素，所以不能对齐进行递增或者解引用的操作*

**特殊情形**：如果容器为空，那么`begin`和`end`返回的是同一个迭代器，都是尾后迭代器（*可以利用这个特性来判断容器是否为空，防止一些不合法的操作*）

一般不在意迭代器类型，所以可以用`auto`关键字

* 迭代器运算符

  <img src="C:\Users\韦澜\AppData\Roaming\Typora\typora-user-images\image-20221012153058283.png" alt="image-20221012153058283" style="zoom: 67%;" />

  尤其常用的应该是第一项：

  `*iter`返回迭代器`iter`所指元素的引用

  **如果试图解引用一个非法迭代器/尾后迭代器，那都是未被定义的。**

* 将迭代器从一个元素移动到另外一个元素

  **写`for`循环的时候尽量使用`!=`，而不要使用`<`。因为所有标准库容器的迭代器都定义了`==`和`!=`，但是大多数都没有定义`<`**

* 迭代器类型

  不需要知道迭代器的精确类型（就像`string`和`vector`的`size_type`的数据类型一样）

  ```c++
  vector<int>::iterator it;  //it可以读写vector<int>的元素
  string::iterator it2;  //it2可以读写string对象中的元素
  
  vector<int>::const_iterator it3;  //const_iterator只能读元素，不能写元素
  string::const_iterator it4;
  ```

* `begin`和`end`运算符

  返回的具体类型由对象是否是常量决定，有时候想要一个常量类型的迭代器，可以用`cbegin`和`cend`这两个成员函数

* 结合解引用和成员访问操作

  箭头运算符：`->`

  `it->mem`等价于`(*it).mem`

**凡是用了迭代器的循环体，都不要向迭代器所属的容器添加元素**

> 具体来说，就是`vector`可以动态增长的这一特性有一定的副作用：1）不能在范围`for`循环中向`vector`对象添加元素；2）任何一种可能改变`vector`对象容量的操作（比如`push_back`）都会使得迭代器失效

#### 3.4.2 迭代器运算

| `iter + n`           |                                                              |
| -------------------- | ------------------------------------------------------------ |
| `iter - n`           |                                                              |
| `iter += n`          | 复合语句，将向前移动过的迭代器的结果再赋给这个迭代器         |
| `iter -= n`          |                                                              |
| `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离；参与运算的两个迭代器必须**指向的是同一个容器中的元素或者尾元素的下一位置** |
| `>`、`<`、`>=`、`<=` |                                                              |

**注**：两个迭代器之间的距离指的是**右侧的迭代器向前移动多少位置就能追上左侧的迭代器**，类型是**`difference_type`**，是带符号的类型。

* 使用迭代器运算

  例子：二分法查找（给定的序列是**有序的**）

```c++
auto beg = text.begin();
auto end = text.end();
auto mid = (end - begin) / 2 + text.begin();
while (mid != end && mid != sought)
{
    if (sought < *mid)
    	end = mid;
    else
        begin = mid;
    mid = begin + (begin + end) / 2;
}
```

**tips:** 关于这个`mid`怎么取，可以取成`mid = (begin + end) / 2`也可以取成上面那个例子那样，但是后者更好一点，因为前者在`begin`和`end`都很大的时候很容易溢出。

### 3.5 数组

**和`vector`有一定相似之处，但是如果不确定元素的确切个数的话，请使用`vector`**。

#### 3.5.1 定义和初始化内置数组

* 字符数组的特殊性

  ```c++
  char a1[] = {'C', '+', '+'}; //列表初始化，没有空字符
  char a2[] = {'C', '+', '+', '\0'}; //列表初始化，有显式的空字符
  char a3[] = {'C++'}; //自动添加空字符
  ```

  如果用字符串字面值初始化字符数组的话，要注意末尾会自动补上一个空字符，表示字符串的结尾，所以在定义数组维度的时候要预留一位。

* 不允许拷贝和赋值

  不能直接把数组的内容拷贝给其它数组/为其它数组赋值

* 理解复杂的数组声明

  ```c++
  int *ptrs[10]; //含有10个整型指针的数组
  int &refs[10] = /*  ?  */; //非法，不存在引用的数组
  int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
  int (&arrRef)[10] = arr; //arrRef是一个对有10个整数的数组的引用
  ```

**注：**在主函数内外各定义一个`int`数组，且不进行初始化，那么这两个数组的值是不一样的。在主函数外的`int`数组会被存储到堆里，这个数组的值会被全部初始化为0；在主函数内定义的`int`数组则是存储到栈里，值是不能够确定的。*栈由系统自动分配，速度较快。 但程序员是无法控制的。 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。*

#### 3.5.2 访问数组元素

* 数组下标的类型：`size_t`，这是一种无符号类型，在`stddef`标准库中被定义。*顺便，`vector`的下标类型可以通过vec.size()获取*
* 数组下标需要程序员检查，**及时顺利通过编译并执行，也不能肯定它不包含此类致命的错误**

#### 3.5.3 指针和数组

